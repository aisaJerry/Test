<html>
	<head></head>
	<body>
		<span id='c'></span>
		<span id='obj'>
	</body>
	<script type="text/javascript">
		/*通过getter和setter可以监听设置和取值事件*/

		/*case 1*/
		console.info("case 1==================================================")
		var o={
			a:'111',
			b:'222',
			c:"333",
			get b(){
				console.log('getted');
				//return this.b;  //N1:这里return this.b会死循环调用 b(),因为此时的this.b已经变成了一个函数
			},
			set c(x){
				console.log('setted');
				let cDoc = document.querySelector('#c').innerHTML=x;
			}
		}
		o.c="555";
		let d = o.b;

		console.info("case 2==================================================")

		/*case 2*/
		let obj = {
			val:'1'
		}

		obj.__defineGetter__('val',function(){console.log('val of obj getted')});
		obj.__defineSetter__('val',function(newVal){console.log('val of obj has be setted '+newVal)})

		let aaa = obj.val;
		obj.val = '2222';


		console.info("case 3==================================================")

		/*case 3 通过一个函数封装，把值作为参数传入，get和set时不操作属性本身，而是代理给值的那个参数val,避免以上N1处死循环的情况*/
		function transformPropertyToGetSet(obj,key,val){//给单个属性添加get和set

			Object.defineProperty(obj,key,{
				enumerable: true,
			    configurable: true,
			    get: function(){
			    	console.log('transformPropertyToGetSet getted');
			    	return val;
			    },
			    set: function(newVal){
			    	console.log('transformPropertyToGetSet has been setted');
			    	val = newVal;
			    }
			})
		}

		let dataObj = {};
		transformPropertyToGetSet(dataObj,'dataA','2'); //通过封装的函数添加对象的元素
		dataObj.dataA = 'after setted 333';
		let geta = dataObj.dataA;
		console.log(geta);// 正确输出设置后的值333，说明set的设置和get的返回是有作用的

		console.info("case vue simple=========================================")
		/*===vue simple case===*/
		var dep=[];
		function defineReactive(obj, key, val) {
		  // 有自定义的 property，则用自定义的 property
		  var property = Object.getOwnPropertyDescriptor(obj, key);
		  if(property && property.configurable === false) {
		    return;
		  }

		  var getter = property && property.get;
		  var setter = property && property.set;
		  Object.defineProperty(obj, key, {
		    enumerable: true,
		    configurable: true,
		    get: function() {
		      var value = getter ? getter.call(obj) : val;
		      dep.push(value);
		      return value;
		    },
		    set: function(newVal) {
		      var value = getter ? getter.call(obj) : val;
		      // set 值与原值相同，则不更新
		      if(newVal === value) {
		        return;
		      }
		      if(setter) {
		        setter.call(obj, newVal);
		      } else {
		        val = newVal;
		      }
		      console.log(dep);
		    }
		  });
		}

		var a = {};
		defineReactive(a, 'a', 12);
		// 调用 getter，12 被压入 dep，此时 dep 值为 [12]
		console.log(a.a);
		// 调用 setter，输出 dep ([12])
		a.a = 24;
		// 调用 getter，24 被压入 dep，此时 dep 值为 [12, 24]
		a.a;


	</script>
</html>